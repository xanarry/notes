# java访问控制符的意义与控制范围

|               | 同一个类 | 同一个包 | 不同包的子类 | 不同包的非子类 |
| :-----------: | :------: | :------: | :----------: | :------------: |
|  **public**   |    Y     |    Y     |      Y       |       Y        |
| **protected** |    Y     |    Y     |      Y       |                |
|  **default**  |    Y     |    Y     |              |                |
|  **private**  |    Y     |          |              |                |

使用protected修饰符时，对于跨包继承的子类也能访问protected修饰的内容，但是default不行。**所以protected比默认更开放一点**



# 接口中的修饰符





# transient关键词的作用

一个对象只要实现了`Serilizable`接口，这个对象就可以被序列化，序列化包括这个类的所有属性和方法。

然而在实际开发过程中，如果某个类的有些属性需要序列化，而其他属性不需要被序列化，比如一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，那么不想被序列化的变量就可以加上`transient`关键字。 换言之，被`transient`修饰的字段的生命周期仅存于调用者的内存中而不会持久化磁盘里。

**注意：**

1. 一旦变量被`transient`修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后将得到null。
2. `transient`关键字只能修饰变量，而不能修饰方法和类。变量如果是用户自定义类变量，则该类需要实现`Serializable`接口。本地变量是不能被transient关键字修饰的。
3. 一个`static`变量不管是否被`transient`修饰，均不能被序列化。



# Java JNI的使用

JNI即Java Native Interface,Java本地接口，在某些需要高性能的场合如果Java无法满足需求的话，那么可以使用JNI用C/C++实现相关特性，编译成动态链接库之后（Windows的.dll,linux的.so文件）由Java调用。

JNI模式以函数为单位，为C语言与Java语言的交互提供了丰富的支持。其大致模式为：
1. 在类中（假定类名为`Hello`,文件名为`Hello.java`）用`native`关键词修饰用JNI实现的函数签名，无需为该函数提供函数体，因为实现在C语言中。
2. 用`javac`编译`Hello.java`文件生产class文件。
3. 用`javah Hello`为含有native修饰的方法生成`Hello.h`头文件，该文件中包含所有native函数有C语言写好的函数声明。
4. 自定义`Hello.c`文件，并在文件头使用#include引入`Hello.h`文件，然后通过JNI的规范，用C语言实现头文件中声明函数的函数体。


一个简单例子

## java代码

```java
import java.util.*;

public class Hello {
    static {
        System.load("/home/xanarry/桌面/libHello.so");
    }
    
    private int chn;
    private int eng;
    private int math;
    
    public Hello() {}
    public Hello(int c, int e, int m) {
        this.chn = c;
        this.eng = e;
        this.math = m;
    } 
    
    
    public int nsum() {
        return chn + eng + math;
    }
    //一下方法全部通过JNI C语言实现，有静态方法，有对象方法。
    public native int sum();
    public native double avg();
    public native double weightedScore(double chnW, double engW, double mathW);
    public static native void sayHello();
    public static native int  add(int a, int b);
    public static native String strcat(String str, String dst);
    public static native int  strlen(String str);
    public static native int[] sort(int[] ary);
    private native int fact(int n);
    
    public static void main(String agrv[]) {
 	//调用对应方法进行测试。
        sayHello();
        System.out.println(add(12, 100));
        System.out.println(strcat("abc", "xyz"));
        System.out.println(strlen("12345"));
        
        int[] ary = {3,2,1,4,5,6};
        int[] result = sort(ary);
        
        for (int i : ary) {
            System.out.print(i + ",");
        }
        System.out.println();
        
        for (int i : result) {
            System.out.print(i + ",");
        }
        System.out.println();
        
        Hello h = new Hello(11,22,33);
        System.out.println(h.fact(4));
        
        System.out.println(h.sum());
        System.out.println(h.avg());
        System.out.println(h.weightedScore(0.1, 0.2, 0.3));
        
    }
}
```


## 头文件

`javah Hello` 生产的头文件如下：

```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class Hello */

#ifndef _Included_Hello
#define _Included_Hello
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     Hello
 * Method:    sum
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_Hello_sum
  (JNIEnv *, jobject);

/*
 * Class:     Hello
 * Method:    avg
 * Signature: ()D
 */
JNIEXPORT jdouble JNICALL Java_Hello_avg
  (JNIEnv *, jobject);

/*
 * Class:     Hello
 * Method:    weightedScore
 * Signature: (DDD)D
 */
JNIEXPORT jdouble JNICALL Java_Hello_weightedScore
  (JNIEnv *, jobject, jdouble, jdouble, jdouble);

/*
 * Class:     Hello
 * Method:    sayHello
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_Hello_sayHello
  (JNIEnv *, jclass);

/*
 * Class:     Hello
 * Method:    add
 * Signature: (II)I
 */
JNIEXPORT jint JNICALL Java_Hello_add
  (JNIEnv *, jclass, jint, jint);

/*
 * Class:     Hello
 * Method:    strcat
 * Signature: (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_Hello_strcat
  (JNIEnv *, jclass, jstring, jstring);

/*
 * Class:     Hello
 * Method:    strlen
 * Signature: (Ljava/lang/String;)I
 */
JNIEXPORT jint JNICALL Java_Hello_strlen
  (JNIEnv *, jclass, jstring);

/*
 * Class:     Hello
 * Method:    sort
 * Signature: ([I)[I
 */
JNIEXPORT jintArray JNICALL Java_Hello_sort
  (JNIEnv *, jclass, jintArray);

/*
 * Class:     Hello
 * Method:    fact
 * Signature: (I)I
 */
JNIEXPORT jint JNICALL Java_Hello_fact
  (JNIEnv *, jobject, jint);

//这个函数是手动添加的，用来实现一个递归函数
jint fact(jint);
#ifdef __cplusplus
}
#endif
#endif

```



## 函数实现

`Hello.c`实现了头文件声明的函数

```c
#include "Hello.h"
#include <string.h>
#include <stdlib.h>

/*
 * Class:     Hello
 * Method:    sum
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_Hello_sum (JNIEnv *env, jobject jobj) {
    jclass hello = (*env)->GetObjectClass(env, jobj);
    jfieldID chnID = (*env)->GetFieldID(env, hello, "chn", "I");
    jfieldID engID = (*env)->GetFieldID(env, hello, "eng", "I");
    jfieldID mathID = (*env)->GetFieldID(env, hello, "math", "I");
    
    jint chn =  (*env)->GetIntField(env, jobj, chnID);
    jint eng =  (*env)->GetIntField(env, jobj, engID);
    jint math = (*env)->GetIntField(env, jobj, mathID);
    
    return chn + eng + math;
}

/*
 * Class:     Hello
 * Method:    avg
 * Signature: ()D
 */
JNIEXPORT jdouble JNICALL Java_Hello_avg (JNIEnv *env, jobject jobj) {
    jclass hello = (*env)->GetObjectClass(env, jobj);
    jmethodID sum = (*env)->GetMethodID(env, hello, "nsum", "()I");
    if (sum == NULL) {
        return 0.0;
    }
    jint isum = (*env)->CallIntMethod(env, jobj, sum);
    return isum / 3.0;
}

/*
 * Class:     Hello
 * Method:    weightedScore
 * Signature: (DDD)D
 */
JNIEXPORT jdouble JNICALL Java_Hello_weightedScore (JNIEnv *env, jobject jobj, jdouble chnW, jdouble engW, jdouble mathW) {
    jclass hello = (*env)->GetObjectClass(env, jobj);
    jfieldID chnID = (*env)->GetFieldID(env, hello, "chn", "I");
    jfieldID engID = (*env)->GetFieldID(env, hello, "eng", "I");
    jfieldID mathID = (*env)->GetFieldID(env, hello, "math", "I");
    
    jint chn =  (*env)->GetIntField(env, jobj, chnID);
    jint eng =  (*env)->GetIntField(env, jobj, engID);
    jint math = (*env)->GetIntField(env, jobj, mathID);
    
    return chn * chnW + eng * engW + math * mathW;
}
  
  
/*
 * Class:     Hello
 * Method:    sayHello
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_Hello_sayHello (JNIEnv *env, jclass hello) {
    printf("hello world\n");
}


/*
 * Class:     Hello
 * Method:    add
 * Signature: (II)I
 */
JNIEXPORT jint JNICALL Java_Hello_add (JNIEnv * env, jclass hello, jint a, jint b) {
    return a + b;
}

/*
 * Class:     Hello
 * Method:    strcat
 * Signature: (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
 */
//拼接两个字符串，演示如何从java的String到C语言的String
JNIEXPORT jstring JNICALL Java_Hello_strcat (JNIEnv *env, jclass hello, jstring str, jstring dst) {
    //从javaString到C语言的String
    const char *cstr = (*env)->GetStringUTFChars(env, str, 0);
    const char *cdst = (*env)->GetStringUTFChars(env, dst, 0);
    int lena = strlen(cstr);
    int lenb = strlen(cdst);
    //printf("%d %s\n", lena, cstr);
    //printf("%d %s\n", lenb, cdst);
    char *newStr = (char *) malloc(sizeof(char) * (lena + lenb));
    memcpy(newStr, cstr, lena);
    memcpy(newStr + lena, cdst, lenb);
    newStr[lena + lenb] = '\0';
    //printf("%d %s\n", lenb + lenb, newStr);
    (*env)->ReleaseStringUTFChars(env, str, cstr);
    (*env)->ReleaseStringUTFChars(env, dst, cdst);
    //从C语言的string构造java的String
    return (*env)->NewStringUTF(env, newStr);
}

/*
 * Class:     Hello
 * Method:    strlen
 * Signature: (Ljava/lang/String;)I
 */
//求字符串长度
JNIEXPORT jint JNICALL Java_Hello_strlen (JNIEnv *env, jclass hello, jstring str) {
    return strlen((*env)->GetStringUTFChars(env, str, 0));
}

/*
 * Class:     Hello
 * Method:    sort
 * Signature: ([I)[I
 */

//对数组排序并返回，演示数组的使用
JNIEXPORT jintArray JNICALL Java_Hello_sort (JNIEnv *env, jclass hello, jintArray ary) {
    jsize len = (*env)->GetArrayLength(env, ary);
    //获取C语言能操作的数组
    jint  *array = (*env)->GetIntArrayElements(env, ary, 0);
    //选择排序
    for (int i = 0; i < len - 1; i++) {
        int k = i;
        for (int j = i + 1; j < len; j++) {
            k = (array[j] < array[k]) ? j : k;
        }
        if (k != i) {
            int tmp = array[k];
            array[k] = array[i];
            array[i] = tmp;
        }
    }
    //创建新的java数组
    jintArray result = (*env)->NewIntArray(env, len);
    if (result == NULL) {
        return NULL;
    }
    //为新开辟的数组赋值为有序的数组
    (*env)->SetIntArrayRegion(env, result, 0, len, array);
    return result;
}

/*
 * Class:     Hello
 * Method:    fact
 * Signature: (I)I
 */

//求阶乘
JNIEXPORT jint JNICALL Java_Hello_fact (JNIEnv *env, jobject jobj, jint n) {
    if (n < 0) {
        return 0;
    } else {
        return fact(n);//使用递归函数计算
    }
}

jint fact(jint n) {
    if (n <= 1) {
        return 1;
    }
    return n * fact(n - 1);
}

```



## 编译

编译该C文件为动态链接库

```shell
gcc --shared Hello.c -o libhello.so -fPIC -I /usr/lib/jvm/java-8-openjdk-amd64/include/ -I /usr/lib/jvm/java-8-openjdk-amd64/include/linux
```



## 错误解决

可能遇到的错误：

**`fatal error: jni.h`: 没有那个文件或目录**：GCC -I jdk的include目录
**`fatal error: jni_md.h`: 没有那个文件或目录**：GCC -I jdk的include目录中的Linux（Linux环境）目录，win32（Windows环境）目录
**Windows下可能有找不到宏`jlong`的定义的错误**：GCC加参数-Djlong="long long"





测试结果

![](assets/jni-output.png)





# Java中的强引用，弱引用，软引用，虚引用

**强引用（Strong Reference）**：强引用就是值在程序代码之中普遍存在的，类似`Object o =  new Object()`，这类引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象，除非直接将变量赋值为`null`。

**软引用（Soft Reference）**：软引用是用来描述一些_还有用但并非必需_的对象。在系统将要发生内存内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。

**弱引用（Week Reference）**：弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下次垃圾回收发生之前。当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。

**虚引用（Phantom Reference）**：虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来去的一个对象实例。为对象设置虚引用关联的唯一目的就是能在这个对象被垃圾回收器回收时收到一个系统通知。





# Java的异常处理以与finally块

在一个处理异常的代码中，如果代码本身，每个异常处理的代码都有return语句。

如果没有finally：如果没有异常发生则正常返回，如果发生了异常，就在处理异常的代码中返回。

如果有finally：业务代码块和处理异常代码块中的return语句都将失效，虚拟机会把finally中的语句插入到前面各个return语句之前。

来看一个具体代码的示例：

> 1.带finally的代码
>
> ```java
> public static int doJob(int a, int b) {
>     int c = 0;
>     try {
>         c = NumOpt.div(a, b);
>         System.out.println("do job");
>         return c;
>     } catch (FloatEception e) {
>         System.out.println(e.getMessage());
>         return 0x1111;
>     } catch (NegetiveEception e) {
>         System.out.println(e.getMessage());
>         return 0x2222;
>     } finally {
>         System.out.println("do finally");
>         return 0x9999;
>     }
> }
> ```
>
> 
>
> 2.不带finally的代码
>
> ```java
> public static int doJob(int a, int b) {
>     int c = 0;
>     try {
>         c = NumOpt.div(a, b);
>         System.out.println("do job");
>         return c;
>     } catch (FloatEception e) {
>         System.out.println(e.getMessage());
>         return 0x1111;
>     } catch (NegetiveEception e) {
>         System.out.println(e.getMessage());
>         return 0x2222;
>     }
> }
> 
> ```



下面来看上面两个函数的字节码有什么区别

> 1.带finally函数的字节码
>
> ```assembly
> #调用NumOpt.div(a, b);
> iconst_0        
> istore_2        
> iload_0         
> invokestatic    #7   // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
> iload_1         
> invokestatic    #7   // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
> invokestatic    #8   // Method com/test/NumOpt.div:(Ljava/lang/Integer;Ljava/lang/Integer;)I
> istore_2        
> getstatic       #9   // Field java/lang/System.out:Ljava/io/PrintStream;
> ldc             #10  // String do job
> invokevirtual   #11  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
> iload_2         
> #调用NumOpt.div(a, b) 结束在return c;之前
> #插入finally代码块
> istore_3        
> getstatic       #9   // Field java/lang/System.out:Ljava/io/PrintStream;
> ldc             #12  // String do finally
> invokevirtual   #11  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
> ldc             #13  // int 39321 -> 0x9999
> ireturn     
> #finally代码块执行介绍，返回finally中的值
> 
> 
> #FloatEception异常块代码
> astore_3        
> getstatic       #9   // Field java/lang/System.out:Ljava/io/PrintStream;
> aload_3         
> invokevirtual   #14  // Method com/test/FloatEception.getMessage:()Ljava/lang/String;
> invokevirtual   #11  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
> sipush          4369 //0x1111
> #FloatEception异常块代码介绍，没有返回指令
> #插入finally代码块
> istore          4    
> getstatic       #9   // Field java/lang/System.out:Ljava/io/PrintStream;
> ldc             #12  // String do finally
> invokevirtual   #11  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
> ldc             #13  // int 39321 -> 0x9999
> ireturn        
> #finally代码块执行介绍，返回finally中的值
> 
> 
> #NegetiveEception异常块代码
> astore_3        
> getstatic       #9   // Field java/lang/System.out:Ljava/io/PrintStream;
> aload_3         
> invokevirtual   #15  // Method com/test/NegetiveEception.getMessage:()Ljava/lang/String;
> invokevirtual   #11  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
> sipush          8738 //0x2222
> #NegetiveEception异常块代码介绍，没有返回指令
> #插入finally代码块
> istore          4    
> getstatic       #9   // Field java/lang/System.out:Ljava/io/PrintStream;
> ldc             #12  // String do finally
> invokevirtual   #11  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
> ldc             #13  // int 39321
> ireturn         
> #finally代码块执行介绍，返回finally中的值
> 
> #finally代码块
> astore          5    
> getstatic       #9   // Field java/lang/System.out:Ljava/io/PrintStream;
> ldc             #12  // String do finally
> invokevirtual   #11  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
> ldc             #13  // int 39321
> ireturn         
> ```
>
> 
>
> 2.不带finally函数的字节码
>
> ```assembly
> #调用NumOpt.div(a, b);
> iconst_0        
> istore_2        
> iload_0         
> invokestatic    #7   // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
> iload_1         
> invokestatic    #7   // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
> invokestatic    #8   // Method com/test/NumOpt.div:(Ljava/lang/Integer;Ljava/lang/Integer;)I
> istore_2        
> getstatic       #9   // Field java/lang/System.out:Ljava/io/PrintStream;
> ldc             #10  // String do job
> invokevirtual   #11  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
> iload_2 
> ireturn  //有返回值
> 
> #FloatEception异常块代码
> astore_3        
> getstatic       #9   // Field java/lang/System.out:Ljava/io/PrintStream;
> aload_3         
> invokevirtual   #12  // Method com/test/FloatEception.getMessage:()Ljava/lang/String;
> invokevirtual   #11  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
> sipush          4369 
> ireturn  //有返回值  
> 【ireturn保留，并没有在此插入finally的代码】
> 
> #NegetiveEception异常块代码
> astore_3        
> getstatic       #9   // Field java/lang/System.out:Ljava/io/PrintStream;
> aload_3         
> invokevirtual   #13  // Method com/test/NegetiveEception.getMessage:()Ljava/lang/String;
> invokevirtual   #11  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
> sipush          8738 
> ireturn  //有返回值
> 【ireturn保留，并没有在此插入finally的代码】
> 
> ```



# 类中静态变量的引用

类中的静态变量，通过`类名.变量名`与`实例.变量名`都能访问到其值。但由于静态变量一定是先于实例存在，所以惯例是通过类名访问静态变量。



# 代理与动态代理

代理模式使用一个代理接口，表示需要被代理执行的有哪些方法。代理对象与被代理对象都要实现该接口。被代理对象在接口中实现具体的操作；代理对象持有一个代理对象的引用，在接口中调用被代理对象同名的接口方法，此外可以在调用前后做更多额外操作。



一个静态代理和动态代理的例子：

```java
interface Work { //定义方法接口
    void doSomething();
    void getMoney(int m);
}

class Worker implements Work{  //实际做工作的对象
    @Override
    public void doSomething() {
        System.out.println("do something");
    }

    @Override
    public void getMoney(int m) {
        System.out.println("get money: " + m);
    }
}


class WorkerProxy implements Work { //普通代理（静态代理）
    private Work proxied; //持有一个被代理的对象
    WorkerProxy(Work work) {
        this.proxied = work;
    }

    @Override
    public void doSomething() { 
        //代理被代理的对象做工作，（调用被代理对象的方法，在方法前后可以做更多额外的工作）
        System.out.println("before do something");
        proxied.doSomething();
    }

    @Override
    public void getMoney(int m) {
        System.out.println("before get money");
        proxied.getMoney(m);
    }
}

//使用反射，使用更加灵活的动态代理方法
class DynamicProxyHandler implements InvocationHandler {
    private Object proxied; //持有一个被代理的对象
    DynamicProxyHandler(Object proxied) {
        this.proxied = proxied;
    }

    /*
     * proxy:  代理对象
     * method: 被调用的方法
     * args:   被调用方法的参数列表
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 定义代理方式
        System.out.println(proxy.getClass());
        System.out.println("before " + method);
        return method.invoke(proxied, args); //执行被代理对象的方法
    }
}

class PRT {
    public static void main(String[] args) throws IllegalAccessException, InstantiationException, ClassNotFoundException {
        doJob(new Worker()); //原始对象
        doJob(new WorkerProxy(new Worker())); //使用静态代理
        System.out.println("--------------");
        
        //使用动态代理，
        Work proxy = (Work) Proxy.newProxyInstance(
            	Work.class.getClassLoader(), //一个类加载器
                new Class[] {Work.class},    //希望该代理实现的接口，可以实现多个接口
                new DynamicProxyHandler(new Worker())); //被代理的对象
        doJob(proxy);
    }

    static void doJob(Work work) {
        work.doSomething();
        work.getMoney();
    }
}
```







# 其他

java可变参数的本质是传入一个数组，当一个方法接收可变参数时，如果调用者传入的多个参数，那么编译器将这写参数构造为数组给方法传入，如果调用方法时传入的就是一个数组，那么数组中的每个元素都是方法的参数；如果传入数组之后还跟有其他参数，数组本身本当成一个参数处理。**可变参数也可以不传入任何参数**



finalize方法在垃圾回收器准备回收某个对象时，会调用其finalize方法一次，并在下次垃圾回收动作发生时才真正回收掉该对象的空间，finalize方法在对象的生命周期中只会被调用一次。但是finalize方法不一定一定会被出发，应为有的对象可能在程序的运行期间内都没有被回收。

finalize的一个应用场景是如果java使用的本地代码申请了内存，由于垃圾回收器没法回收本地方法申请的内存，可以在finalize方法中使用本地方法释放。



执行`System.gc()`，只是通知GC建议运行，但是Java语言规范并不保证GC一定会执行。



每一个class定义中只要有定义main方法，那么只要在可访问域，都可以执行`java 类名`从main方法开始运行程序。



**运行时（动态）绑定针对的范畴只是对象的方法，访问属性的时候，访问的是声明对象类的属性，而不是实际对象的属性**。



如果基类定义的方法没有声明抛出一样，那么子类重写该方法的时候也不能声明抛出任何异常，因为如果基类对象指向子类对象引用时，如果子类抛出异常将无法检测；反之，如果基类方法声明的异常抛出，子类可以不抛出异常或者抛出基类异常对象的子类异常。



定义数组或List的时候给定初始元素的方式：

```java
List<Integer> intList = Arrays.asList(1,2,3);
Integer[]     intAray = new Integer[] {1,2,3};
```





使用类的三个准备步骤：

1. **加载**，这是有类加载器执行的，该步骤查找字节码，并从这些字节码中创建一个Class对象
2. **链接**，在链接阶段将验证类中的字节码，为静态域分配存储空间，如果必须的话，将解析这个类创建的对其他类的所有引用。（**static final变量在分配存储空间时直接给值，static变量仅分配空间，在初始化阶段赋值**）
3. **初始化**，如果该类有超类，则对其初始化，执行静态初始化器和静态代码块。



使用`类名.class`获取Class对象不会导致类的初始化，而`Class.forName()`会导致类的初始化。

当且仅当访问一个类的静态常量的时候不会引起初始化，即`static final`，如果只有static没有final的话，类会被初始化。





对象类型检测使用`A intanceOf(B)`时，虚拟机在A是B或者A是B的派生类时，都会返回true，A与B没有任何关系或者A是B的父类时，则返回false。 使用A与B的Class对象做比较时，无论使用==还是equals，返回结果一致，都只有A和B是同一个类的时候才返回true。





**基本类型不能作为泛型参数**

Java泛型尖括号中的类型描述符号均为用户全新定义的可替换的类型，如果有定义：

```
class Template<Integer> {
	//在这个类定义中使用Integer var1与T var1的性质一样，var1并不是整数1
	//如果要使用整数类型，要使用java.lang.Integer var1
}
```



泛型接口的参数只确定泛型接口中方法的参数与返回值的类型。**使用泛型接口的时候与类名后面要不要尖括号的类型参数没有必然关系**，使用就是：`class A implements<参数类型>`，A后面没有任何东西，除非A是泛型类。**如果是继承泛型，定义类名和父类名后面都要跟类型参数，形如：`class A<T> extends B<T>`，或者都不用类型参数<T>**



在不是必须使整个类泛型化的才能达到目的的情况下，应该尽可能使用泛型方法。



当使用泛型类时，必须在创建对象的时候指定类型参数的值；而使用泛型方法通常不必指明参数类型，因为编译器会做类型推断找出恰当的类型，如果必须要指明方法，必须在点操作符和方法名之间插入尖括号指明，形如：`duck.<String>getName()`



做一个泛型生成器

```java
//定义生成器接口
interface Generator<T> { T next();}
//实现生成器，泛型类并实现泛型接口
class GeneratorImpl<T> implements Generator<T> {
    private Class<T> type;//保存类对象，使用类型信息生成对象

    public GeneratorImpl(Class<T> type) {
        this.type = type;
    }

    public static <T> Generator<T> create(Class<T> type) {
        return new GeneratorImpl<T>(type);
    }

    @Override
    public T next() {
        try {
            return type.newInstance(); //生成对象返回
        } catch (InstantiationException | IllegalAccessException e) {
            e.printStackTrace();
        }
        return null;
    }
}

public class Test {
    public static void main(String[] args) {
        Generator g = GeneratorImpl.create(String.class);
        System.out.println(g.next());
        Generator g1 = new GeneratorImpl(String.class);
        System.out.println(g1.next());

    }
}
```





泛型中表示一个大类类型（也可以叫做限定边界）时，有下面三种写法：

- ？：表示任何事物，`Class`与`Class<?>`是等价的
- `Class<T extends Number>`：限定类型是Number或者Number的子类，在表示多重继承的时候，尖括号中应该先写类，后写接口，然后把他们用&连接起来，如`class A<T extends 类 & 接口 & 接口>`，只能有一个基类，但可以有多个接口。
- `Class<T super Integer>`：限定类型为Integer的超类



**调用静态方法时，即使该类的对象是null，也能成功调用，但非静态方法会抛空指针异常**



对于在泛型中创建数组，`Array.newInstance(类型,数量)`是推荐的方式



在泛型类中，由于类型擦除的原因，任何在运行时需要知道确切类型信息的操作都将无法工作。比如创建对象，调用泛型对象的方法等。如果需要在泛型类中创建泛型对象，有三种方法：

1. 第一种就是传入类型信息Class<T>，然后调用newInstance()方法，但这样做有个缺陷就是必须要求传入的类型有默认构造函数，否则将抛出异常，比如Integer。
2. 使用工厂方法，能解决这个缺陷，但代码繁琐一点。
3. 使用模板方法。

使用类型信息并调用newInstance方法：

```java
class A<T> {
    private T ele;
    public A(Class<T> type) {
        try {
            this.ele = type.newInstance();使用newInstance方法
        } catch (InstantiationException | IllegalAccessException e) {
            e.printStackTrace();
        }
    }
    public T getEle() { return ele; }
    public void setEle(T ele) { this.ele = ele; }
}
```



使用工厂方法，并自定义对象产生方式：

```java
//定义工厂方法泛型接口
interface Factory<T> {
    T create();
}

//定义泛型类，类中不需要类型信息
class A<T> {
    private T ele;
    //构造函数中传入工厂接口的实现，调用接口方法生产实例对象
    public <F extends Factory<T>> A(F factory) {
        this.ele = factory.create();
    }
    public T getEle() { return ele; }
    public void setEle(T ele) { this.ele = ele; }
}

public class MyList {
    public static void main(String[] args) {
        //使用整数的泛型
        A<Integer> a = new A<Integer>(() -> 100);
        System.out.println(a.getEle());
		//使用字符串的泛型
        A<String> s = new A<String>(()-> "hello world");
        System.out.println(s.getEle());
    }
}
```



使用模板方法：

```java
abstract class A<T> {
    private T ele;
    public A() {
        ele = create();
    }
    public T getEle() { return ele; }
    abstract T create(); //留给子类做具体定义
    public void setEle(T ele) { this.ele = ele; }
}

class B extends A<String> {
    @Override
    String create() {
        return new String("hello world");
    }
}

public class Main {
    public static void main(String[] args) {
        A a = new B();//父类引用子类对象
        System.out.println(a.getEle());
    }
}
```





