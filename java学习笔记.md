# ajava访问控制符的意义与控制范围

|               | 类内部 | 子类 | 本包 | 外部包 |
| :-----------: | :----: | :--: | :--: | :----: |
|  **public**   |   Y    |  Y   |  Y   |   Y    |
|  **default**  |   Y    |  Y   |  Y   |        |
| **protected** |   Y    |  Y   |      |        |
|  **private**  |   Y    |      |      |        |



# 接口中的修饰符





# transient关键词的作用

一个对象只要实现了`Serilizable`接口，这个对象就可以被序列化，序列化包括这个类的所有属性和方法。

然而在实际开发过程中，如果某个类的有些属性需要序列化，而其他属性不需要被序列化，比如一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，那么不想被序列化的变量就可以加上`transient`关键字。 换言之，被`transient`修饰的字段的生命周期仅存于调用者的内存中而不会持久化磁盘里。

**注意：**

1. 一旦变量被`transient`修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后将得到null。
2. `transient`关键字只能修饰变量，而不能修饰方法和类。变量如果是用户自定义类变量，则该类需要实现`Serializable`接口。本地变量是不能被transient关键字修饰的。
3. 一个`static`变量不管是否被`transient`修饰，均不能被序列化。



# Java JNI的使用

JNI即Java Native Interface,Java本地接口，在某些需要高性能的场合如果Java无法满足需求的话，那么可以使用JNI用C/C++实现相关特性，编译成动态链接库之后（Windows的.dll,linux的.so文件）由Java调用。

JNI模式以函数为单位，为C语言与Java语言的交互提供了丰富的支持。其大致模式为：
1. 在类中（假定类名为`Hello`,文件名为`Hello.java`）用`native`关键词修饰用JNI实现的函数签名，无需为该函数提供函数体，因为实现在C语言中。
2. 用`javac`编译`Hello.java`文件生产class文件。
3. 用`javah Hello`为含有native修饰的方法生成`Hello.h`头文件，该文件中包含所有native函数有C语言写好的函数声明。
4. 自定义`Hello.c`文件，并在文件头使用#include引入`Hello.h`文件，然后通过JNI的规范，用C语言实现头文件中声明函数的函数体。


一个简单例子

## java代码

```java
import java.util.*;

public class Hello {
    static {
        System.load("/home/xanarry/桌面/libHello.so");
    }
    
    private int chn;
    private int eng;
    private int math;
    
    public Hello() {}
    public Hello(int c, int e, int m) {
        this.chn = c;
        this.eng = e;
        this.math = m;
    } 
    
    
    public int nsum() {
        return chn + eng + math;
    }
    //一下方法全部通过JNI C语言实现，有静态方法，有对象方法。
    public native int sum();
    public native double avg();
    public native double weightedScore(double chnW, double engW, double mathW);
    public static native void sayHello();
    public static native int  add(int a, int b);
    public static native String strcat(String str, String dst);
    public static native int  strlen(String str);
    public static native int[] sort(int[] ary);
    private native int fact(int n);
    
    public static void main(String agrv[]) {
 	//调用对应方法进行测试。
        sayHello();
        System.out.println(add(12, 100));
        System.out.println(strcat("abc", "xyz"));
        System.out.println(strlen("12345"));
        
        int[] ary = {3,2,1,4,5,6};
        int[] result = sort(ary);
        
        for (int i : ary) {
            System.out.print(i + ",");
        }
        System.out.println();
        
        for (int i : result) {
            System.out.print(i + ",");
        }
        System.out.println();
        
        Hello h = new Hello(11,22,33);
        System.out.println(h.fact(4));
        
        System.out.println(h.sum());
        System.out.println(h.avg());
        System.out.println(h.weightedScore(0.1, 0.2, 0.3));
        
    }
}
```


## 头文件

`javah Hello` 生产的头文件如下：

```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class Hello */

#ifndef _Included_Hello
#define _Included_Hello
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     Hello
 * Method:    sum
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_Hello_sum
  (JNIEnv *, jobject);

/*
 * Class:     Hello
 * Method:    avg
 * Signature: ()D
 */
JNIEXPORT jdouble JNICALL Java_Hello_avg
  (JNIEnv *, jobject);

/*
 * Class:     Hello
 * Method:    weightedScore
 * Signature: (DDD)D
 */
JNIEXPORT jdouble JNICALL Java_Hello_weightedScore
  (JNIEnv *, jobject, jdouble, jdouble, jdouble);

/*
 * Class:     Hello
 * Method:    sayHello
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_Hello_sayHello
  (JNIEnv *, jclass);

/*
 * Class:     Hello
 * Method:    add
 * Signature: (II)I
 */
JNIEXPORT jint JNICALL Java_Hello_add
  (JNIEnv *, jclass, jint, jint);

/*
 * Class:     Hello
 * Method:    strcat
 * Signature: (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_Hello_strcat
  (JNIEnv *, jclass, jstring, jstring);

/*
 * Class:     Hello
 * Method:    strlen
 * Signature: (Ljava/lang/String;)I
 */
JNIEXPORT jint JNICALL Java_Hello_strlen
  (JNIEnv *, jclass, jstring);

/*
 * Class:     Hello
 * Method:    sort
 * Signature: ([I)[I
 */
JNIEXPORT jintArray JNICALL Java_Hello_sort
  (JNIEnv *, jclass, jintArray);

/*
 * Class:     Hello
 * Method:    fact
 * Signature: (I)I
 */
JNIEXPORT jint JNICALL Java_Hello_fact
  (JNIEnv *, jobject, jint);

//这个函数是手动添加的，用来实现一个递归函数
jint fact(jint);
#ifdef __cplusplus
}
#endif
#endif

```



## 函数实现

`Hello.c`实现了头文件声明的函数

```c
#include "Hello.h"
#include <string.h>
#include <stdlib.h>

/*
 * Class:     Hello
 * Method:    sum
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_Hello_sum (JNIEnv *env, jobject jobj) {
    jclass hello = (*env)->GetObjectClass(env, jobj);
    jfieldID chnID = (*env)->GetFieldID(env, hello, "chn", "I");
    jfieldID engID = (*env)->GetFieldID(env, hello, "eng", "I");
    jfieldID mathID = (*env)->GetFieldID(env, hello, "math", "I");
    
    jint chn =  (*env)->GetIntField(env, jobj, chnID);
    jint eng =  (*env)->GetIntField(env, jobj, engID);
    jint math = (*env)->GetIntField(env, jobj, mathID);
    
    return chn + eng + math;
}

/*
 * Class:     Hello
 * Method:    avg
 * Signature: ()D
 */
JNIEXPORT jdouble JNICALL Java_Hello_avg (JNIEnv *env, jobject jobj) {
    jclass hello = (*env)->GetObjectClass(env, jobj);
    jmethodID sum = (*env)->GetMethodID(env, hello, "nsum", "()I");
    if (sum == NULL) {
        return 0.0;
    }
    jint isum = (*env)->CallIntMethod(env, jobj, sum);
    return isum / 3.0;
}

/*
 * Class:     Hello
 * Method:    weightedScore
 * Signature: (DDD)D
 */
JNIEXPORT jdouble JNICALL Java_Hello_weightedScore (JNIEnv *env, jobject jobj, jdouble chnW, jdouble engW, jdouble mathW) {
    jclass hello = (*env)->GetObjectClass(env, jobj);
    jfieldID chnID = (*env)->GetFieldID(env, hello, "chn", "I");
    jfieldID engID = (*env)->GetFieldID(env, hello, "eng", "I");
    jfieldID mathID = (*env)->GetFieldID(env, hello, "math", "I");
    
    jint chn =  (*env)->GetIntField(env, jobj, chnID);
    jint eng =  (*env)->GetIntField(env, jobj, engID);
    jint math = (*env)->GetIntField(env, jobj, mathID);
    
    return chn * chnW + eng * engW + math * mathW;
}
  
  
/*
 * Class:     Hello
 * Method:    sayHello
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_Hello_sayHello (JNIEnv *env, jclass hello) {
    printf("hello world\n");
}


/*
 * Class:     Hello
 * Method:    add
 * Signature: (II)I
 */
JNIEXPORT jint JNICALL Java_Hello_add (JNIEnv * env, jclass hello, jint a, jint b) {
    return a + b;
}

/*
 * Class:     Hello
 * Method:    strcat
 * Signature: (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
 */
//拼接两个字符串，演示如何从java的String到C语言的String
JNIEXPORT jstring JNICALL Java_Hello_strcat (JNIEnv *env, jclass hello, jstring str, jstring dst) {
    //从javaString到C语言的String
    const char *cstr = (*env)->GetStringUTFChars(env, str, 0);
    const char *cdst = (*env)->GetStringUTFChars(env, dst, 0);
    int lena = strlen(cstr);
    int lenb = strlen(cdst);
    //printf("%d %s\n", lena, cstr);
    //printf("%d %s\n", lenb, cdst);
    char *newStr = (char *) malloc(sizeof(char) * (lena + lenb));
    memcpy(newStr, cstr, lena);
    memcpy(newStr + lena, cdst, lenb);
    newStr[lena + lenb] = '\0';
    //printf("%d %s\n", lenb + lenb, newStr);
    (*env)->ReleaseStringUTFChars(env, str, cstr);
    (*env)->ReleaseStringUTFChars(env, dst, cdst);
    //从C语言的string构造java的String
    return (*env)->NewStringUTF(env, newStr);
}

/*
 * Class:     Hello
 * Method:    strlen
 * Signature: (Ljava/lang/String;)I
 */
//求字符串长度
JNIEXPORT jint JNICALL Java_Hello_strlen (JNIEnv *env, jclass hello, jstring str) {
    return strlen((*env)->GetStringUTFChars(env, str, 0));
}

/*
 * Class:     Hello
 * Method:    sort
 * Signature: ([I)[I
 */

//对数组排序并返回，演示数组的使用
JNIEXPORT jintArray JNICALL Java_Hello_sort (JNIEnv *env, jclass hello, jintArray ary) {
    jsize len = (*env)->GetArrayLength(env, ary);
    //获取C语言能操作的数组
    jint  *array = (*env)->GetIntArrayElements(env, ary, 0);
    //选择排序
    for (int i = 0; i < len - 1; i++) {
        int k = i;
        for (int j = i + 1; j < len; j++) {
            k = (array[j] < array[k]) ? j : k;
        }
        if (k != i) {
            int tmp = array[k];
            array[k] = array[i];
            array[i] = tmp;
        }
    }
    //创建新的java数组
    jintArray result = (*env)->NewIntArray(env, len);
    if (result == NULL) {
        return NULL;
    }
    //为新开辟的数组赋值为有序的数组
    (*env)->SetIntArrayRegion(env, result, 0, len, array);
    return result;
}

/*
 * Class:     Hello
 * Method:    fact
 * Signature: (I)I
 */

//求阶乘
JNIEXPORT jint JNICALL Java_Hello_fact (JNIEnv *env, jobject jobj, jint n) {
    if (n < 0) {
        return 0;
    } else {
        return fact(n);//使用递归函数计算
    }
}

jint fact(jint n) {
    if (n <= 1) {
        return 1;
    }
    return n * fact(n - 1);
}

```



## 编译

编译该C文件为动态链接库

```shell
gcc --shared Hello.c -o libhello.so -fPIC -I /usr/lib/jvm/java-8-openjdk-amd64/include/ -I /usr/lib/jvm/java-8-openjdk-amd64/include/linux
```



## 错误解决

可能遇到的错误：

**`fatal error: jni.h`: 没有那个文件或目录**：GCC -I jdk的include目录
**`fatal error: jni_md.h`: 没有那个文件或目录**：GCC -I jdk的include目录中的Linux（Linux环境）目录，win32（Windows环境）目录
**Windows下可能有找不到宏`jlong`的定义的错误**：GCC加参数-Djlong="long long"





测试结果

![](assets/jni-output.png)





# Java中的强引用，弱引用，软引用，虚引用

**强引用（Strong Reference）**：强引用就是值在程序代码之中普遍存在的，类似`Object o =  new Object()`，这类引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象，除非直接将变量赋值为`null`。

**软引用（Soft Reference）**：软引用是用来描述一些_还有用但并非必需_的对象。在系统将要发生内存内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。

**弱引用（Week Reference）**：弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下次垃圾回收发生之前。当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。

**虚引用（Phantom Reference）**：虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来去的一个对象实例。为对象设置虚引用关联的唯一目的就是能在这个对象被垃圾回收器回收时收到一个系统通知。





# Java的异常处理以与finally块

在一个处理异常的代码中，如果代码本身，每个异常处理的代码都有return语句。

如果没有finally：如果没有异常发生则正常返回，如果发生了异常，就在处理异常的代码中返回。

如果有finally：业务代码块和处理异常代码块中的return语句都将失效，虚拟机会把finally中的语句插入到前面各个return语句之前。

来看一个具体代码的示例：

> 1.带finally的代码
>
> ```java
> public static int doJob(int a, int b) {
>     int c = 0;
>     try {
>         c = NumOpt.div(a, b);
>         System.out.println("do job");
>         return c;
>     } catch (FloatEception e) {
>         System.out.println(e.getMessage());
>         return 0x1111;
>     } catch (NegetiveEception e) {
>         System.out.println(e.getMessage());
>         return 0x2222;
>     } finally {
>         System.out.println("do finally");
>         return 0x9999;
>     }
> }
> ```
>
> 
>
> 2.不带finally的代码
>
> ```java
> public static int doJob(int a, int b) {
>     int c = 0;
>     try {
>         c = NumOpt.div(a, b);
>         System.out.println("do job");
>         return c;
>     } catch (FloatEception e) {
>         System.out.println(e.getMessage());
>         return 0x1111;
>     } catch (NegetiveEception e) {
>         System.out.println(e.getMessage());
>         return 0x2222;
>     }
> }
> 
> ```



下面来看上面两个函数的字节码有什么区别

> 1.带finally函数的字节码
>
> ```assembly
> #调用NumOpt.div(a, b);
> iconst_0        
> istore_2        
> iload_0         
> invokestatic    #7   // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
> iload_1         
> invokestatic    #7   // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
> invokestatic    #8   // Method com/test/NumOpt.div:(Ljava/lang/Integer;Ljava/lang/Integer;)I
> istore_2        
> getstatic       #9   // Field java/lang/System.out:Ljava/io/PrintStream;
> ldc             #10  // String do job
> invokevirtual   #11  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
> iload_2         
> #调用NumOpt.div(a, b) 结束在return c;之前
> #插入finally代码块
> istore_3        
> getstatic       #9   // Field java/lang/System.out:Ljava/io/PrintStream;
> ldc             #12  // String do finally
> invokevirtual   #11  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
> ldc             #13  // int 39321 -> 0x9999
> ireturn     
> #finally代码块执行介绍，返回finally中的值
> 
> 
> #FloatEception异常块代码
> astore_3        
> getstatic       #9   // Field java/lang/System.out:Ljava/io/PrintStream;
> aload_3         
> invokevirtual   #14  // Method com/test/FloatEception.getMessage:()Ljava/lang/String;
> invokevirtual   #11  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
> sipush          4369 //0x1111
> #FloatEception异常块代码介绍，没有返回指令
> #插入finally代码块
> istore          4    
> getstatic       #9   // Field java/lang/System.out:Ljava/io/PrintStream;
> ldc             #12  // String do finally
> invokevirtual   #11  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
> ldc             #13  // int 39321 -> 0x9999
> ireturn        
> #finally代码块执行介绍，返回finally中的值
> 
> 
> #NegetiveEception异常块代码
> astore_3        
> getstatic       #9   // Field java/lang/System.out:Ljava/io/PrintStream;
> aload_3         
> invokevirtual   #15  // Method com/test/NegetiveEception.getMessage:()Ljava/lang/String;
> invokevirtual   #11  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
> sipush          8738 //0x2222
> #NegetiveEception异常块代码介绍，没有返回指令
> #插入finally代码块
> istore          4    
> getstatic       #9   // Field java/lang/System.out:Ljava/io/PrintStream;
> ldc             #12  // String do finally
> invokevirtual   #11  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
> ldc             #13  // int 39321
> ireturn         
> #finally代码块执行介绍，返回finally中的值
> 
> #finally代码块
> astore          5    
> getstatic       #9   // Field java/lang/System.out:Ljava/io/PrintStream;
> ldc             #12  // String do finally
> invokevirtual   #11  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
> ldc             #13  // int 39321
> ireturn         
> ```
>
> 
>
> 2.不带finally函数的字节码
>
> ```assembly
> #调用NumOpt.div(a, b);
> iconst_0        
> istore_2        
> iload_0         
> invokestatic    #7   // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
> iload_1         
> invokestatic    #7   // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
> invokestatic    #8   // Method com/test/NumOpt.div:(Ljava/lang/Integer;Ljava/lang/Integer;)I
> istore_2        
> getstatic       #9   // Field java/lang/System.out:Ljava/io/PrintStream;
> ldc             #10  // String do job
> invokevirtual   #11  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
> iload_2 
> ireturn  //有返回值
> 
> #FloatEception异常块代码
> astore_3        
> getstatic       #9   // Field java/lang/System.out:Ljava/io/PrintStream;
> aload_3         
> invokevirtual   #12  // Method com/test/FloatEception.getMessage:()Ljava/lang/String;
> invokevirtual   #11  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
> sipush          4369 
> ireturn  //有返回值  
> 【ireturn保留，并没有在此插入finally的代码】
> 
> #NegetiveEception异常块代码
> astore_3        
> getstatic       #9   // Field java/lang/System.out:Ljava/io/PrintStream;
> aload_3         
> invokevirtual   #13  // Method com/test/NegetiveEception.getMessage:()Ljava/lang/String;
> invokevirtual   #11  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
> sipush          8738 
> ireturn  //有返回值
> 【ireturn保留，并没有在此插入finally的代码】
> 
> ```



# 类中静态变量的引用

类中的静态变量，通过`类名.变量名`与`实例.变量名`都能访问到其值。但由于静态变量一定是先于实例存在，所以惯例是通过类名访问静态变量。



